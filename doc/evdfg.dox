/*! 
\example dfg_master.c
\example dfg_client.c
\example dfg_master2.c
\example dfg_master3.c
\example dfg_client3.c
\example dfg_master4.c

 \page evdfg The EVdfg interface

 \section evdfg-intro EVdfg interface

EVdfg is designed to be a relatively thin layer on top of EVPath that 
enables whole-system multi-process deployment of Data Flow Graphs implemented
with EVPath stones.  Like EVPath, EVdfg has abstractions to create stones,
to assign actions to them, to link stones to each other and to create
sources and sinks of data.  However, in EVdfg the stones created are a
virtual representation of the actual data flow graph that is to be realized
in EVPath, with EVdfg controlling the mapping (and potentially remapping) of
EVPath stones to the participating processes (nodes).

Unlike EVpath, EVdfg has knowledge of the entire set of processes that make
up the 'cohort'.  In particular, in EVdfg a single, differentiated 'Master'
process is responsible for defining the entire DFG.  Code in the master
creates the virtual stones, assigns actions to those stones, links them
together to create the topology, and assigns stones to nodes.  It also
determines when sufficient 'client' processes have joined the DFG, either by
specifying a static list, or by making a decision in a handler as each new
client process joins.  Once all required nodes have joined and the virtual
DFG has been created, it is <i>realized</i> by the master (I.E. actual
EVPath stones are created at the appropriate places) and starts running.
The master may also register handlers that can be called in the event of new
nodes joining, an existing node becoming unreachable, or a stone calling for
reconfiguration.  In the case of each of these, the master may rearrange the
set of virtual stones, moving some, adding others, changing links, etc. and
then can realize the changed DFG.  The master can also (optionally)
arbitrate an orderly shutdown of all client processes with an agreed-upon
exit value. 

Generally, but not necessarily, the master process is also a client and a
participant in the DFG.  The other participating processes are relatively
passive.  They identify their capabilities to the master, but do not
directly contribute stones to the DFG instead accepting the stones that are
assigned to them.

\subsection joining The Joining Process

The subroutine EVdfg_join_dfg() is used to join a client to a master and by
the master process to initiate participation in the DFG it controls.  The
goal of the joining process is for EVdfg to know when all participating
processes have joined and to have a unique name for each process (string
node names are used for stone assignment).  

\subsubsection static_joining Static Joining mode

In the simplest form of the
join, called `static joining' mode, the following things occur:
- Each joining node provides a unique name under which it participates in
the DFG.
- The master provides a fixed list of the names of nodes that must join.
- The joining process is complete when all named nodes have joined.

In this static mode, the pseudocode for the master looks like this:
\code{.c}
    EVmaster test_master;
    char *str_contact;
    char *nodes[] = {"a", "b", NULL};

    /* CM initialization occurs here */

    test_master = EVmaster_create(cm);
    str_contact = EVmaster_get_contact_list(test_master);
    EVmaster_register_node_list(test_master, &nodes[0]);

    /* EVclient capability registration occurs here */

    /* EVdfg stone creation and assignment occurs here */

    EVdfg_realize(test_dfg);

    /* We're node "a" in the DFG */
    EVdfg_join_dfg(test_dfg, "a", str_contact);

    /* Somehow provide str_contact to the other participant(s) */

    /* Wait until everyone has joined */
    EVdfg_ready_wait(test_dfg);
\endcode

While the client is somewhat simpler:
\code{.c}
    EVclient test_client;
    char *str_contact;

    /* CM initialization and EVclient capability registration occurs here */

    test_dfg = EVclient_create(cm);

    /* We're node "b" in the DFG */
    EVdfg_join_dfg(test_dfg, "b", str_contact);

    /* Wait until everyone has joined */
    EVdfg_ready_wait(test_dfg);
\endcode


\subsubsection dynamic_joining Dynamic Joining mode

There are situations in which the "static joining" scenario described above
is too rigid.  'Dynamic Joining' mode relaxes several requirements above.
First, rather than using a static node list (via
EVdfg_register_node_list()) and creating the entire virtual DFG before all
the nodes join, the master registers a EVdfgJoinHandlerFunc which is called
each time a client joins.  This join function may use its own criterion in
deciding when sufficient clients have joined.  When it decides that enough
have joined, then it should create the virtual DFG and call
EVdfg_realize().  In this situation, the requirement that each client
process specify a unique name to EVdfg_join_dfg() is also relaxed.  Instead,
each client can specify a generic name (like "client") and the join handler
can associate a unique canonical name with that client using
EVdfg_assign_canonical_name().  In this case, the canonical names assigned
must be unique and are the names used in EVdfg_assign_node().

In dynamic mode, the pseudocode for the client is unchanged (except that the
specified name need not be unique).  But the code structure for the master
is changes:
\code{.c}
    EVdfg test_dfg;
    char *str_contact;

    /* CM initialization and EVdfg capability registration occurs here */

    test_dfg = EVdfg_create(cm);
    str_contact = EVdfg_get_contact_list(test_dfg);
    EVdfg_node_join_handler (test_dfg, join_handler_func);

    /* We're node "a" in the DFG */
    EVdfg_join_dfg(test_dfg, "client", str_contact);

    /* Somehow provide str_contact to the other participant(s) */

    /* Wait until everyone has joined */
    EVdfg_ready_wait(test_dfg);
\endcode
The join handler function in dynamic mode will generally follow this form:
\code{.c}
void
join_handler_func(EVdfg dfg, char *identifier, void*cur_unused1, void*cur_unused2)
{
    char *canon_name;
    /* Generate a canonical name for this client in canon_name, then assign */
    EVdfg_assign_canonical_name(dfg, identifier, canon_name);

    if ( /* not ready to start running */) return;

    /* EVdfg stone creation and assignment occurs here */

    EVdfg_realize(dfg);
    /* 
     * upon return, the DFG will be instantiated and all clients fall out
     * of EVdfg_ready_wait();
     */
}
\endcode
The join handler function is also used for dynamic reconfiguration of the
DFG, described later.

\subsection capability EVdfg Capability Registration

The phrase "EVdfg capability registration" occurs in the pseudocode comments
above.  Due to the dynamic code generation and FFS-based data representation
in EVPath, many stones can be placed on any process, without regard to
architecture, OS or other considerations.  However data sources and data
sinks necessarily require the cooperation of the receiving process.  In
particular, for an actual EVpath EVsource handle, the process must itself
call EVsubmit() on that handle.  For a sink (an EVPath terminal action,
where data is delivered to a native subroutine), EVdfg must know the jump
address for that subroutine and the exact format of data that it expects.

In order to preserve flexibility for the master to map the DFG to the nodes
as it desires, sources and sink handlers are presented as 'capabilities' in
EVdfg.  That is, sources are created by clients and made available for use,
but the master may or may not actually use them.  Similarly, the jump
addresses and data expectations of handler subroutines are associated with
"handler names" in the client.  Stones with sink actions associated with
those handler names may or may not be assigned individual clients.

\subsubsection source_capability EVdfg Source Capabilities

EVdfg clients register source capabilities by first creating an EVPath
source handle as in normal EVPath, but specifying -1 as the target stone
ID.  Then the EVdfg routine EVdfg_register_source() is used to associate a
name with the source handle.  Unlike EVPath, where EVsource handles are
associated with particular local stones, but are not considered stones
themselves, EVdfg sources are full virtual stones, assignable to different
clients like other virtual stones.  The master creates them with
EVdfg_create_source_stone(), specifying a source name.  This source name
must match a registered source on the client to which the source stone is
assigned.  Source names should be unique within each client, no client
EVsource handle can have more than one EVdfg_stone associated with it.

\subsubsection sink_capability EVdfg Sink Capabilities

EVdfg clients register sink (terminal handler) capabilities by using the
routine EVdfg_register_sink_handler().  Essentially, this establishes an
association between an particular handler subroutine, the FMStructDescList
describing the data it expects, and a handler name.  The master creates sink
stones with EVdfg_create_sink_stone(), or associates a new sink action with
an existing stone with EVdfg_add_sink_action().  In each case, the
handler_name specified in the call must match one that has appeared in a
EVdfg_register_sink_handler() call on the client to which that sink stone
is assigned.  Unlike sources, there is no restriction on how many different
sink stones may be associated with the same sink handler.

\subsubsection run_time Run-time Semantics

It is sometimes useful to clients to know, after a DFG has been realized, if
a particular local source has had an EVdfg source stone associated with it.
The routine EVdfg_source_active(EVsource src) returns a boolean value on
this condition (True if associated, False if not).  During DFG run-time,
clients usually test if a source is active so that they know if data is to
be submitted to it, as in the code below:
\code{.c}
    if (EVdfg_source_active(source_handle)) {
	simple_rec rec;
	generate_simple_record(&rec);
	/* submit would be quietly ignored if source is not active */
	EVsubmit(source_handle, &rec, NULL);
    }
\endcode
As the code comments indicate, a submit to an inactive source would be
quietly ignored by EVPath, but it's better form to test first.

For local sinks, that the actual handler gets called when data arrives is
the only real indication that a source handle has been utilized.  However, a
count of the total sink stones assigned to a particular node is available
via the routine EVdfg_active_sink_count(EVdfg dfg).  This is sometimes
useful for clients who need to know if they should be waiting for particular
data before signalling for shutdown, or if they are just waiting patiently
for the other nodes to complete operation.

\subsubsection capability_example Capability Example 
The code below is a sample for a client that is capable of being a source
for "simple" data, or for hosting terminal stones that handle "simple" data.
\code{.c}
    source_handle = EVcreate_submit_handle(cm, -1, simple_format_list);
    EVdfg_register_source("data_source", source_handle);
    EVdfg_register_sink_handler(cm, "simple_handler", simple_format_list,
				(EVSimpleHandlerFunc) simple_handler, NULL);
\endcode


\subsection stone_creation EVdfg Stone Creation and Assignment

In EVdfg, DFG stone creation occurs much like it does in raw EVPath with a
few major differences:
- The entire DFG is created and ports linked between EVdfg_stones without regard
to what nodes the participating stones might be assigned to.
- EVdfg_assign_node() is used to actually assign EVdfg_stones to specific nodes.
- Bridge stones are not directly created.  Instead, EVdfg inserts bridge
stones transparently when there is a connection between stones assigned to
different nodes.
- EVdfg uses 'source stones', first class enties which can be assigned to
specific nodes like any other EVdfg_stone.
- EVdfg_stones without any other explicit action associated with them act as
split stones.
- While many EVpath action assignment functions have a "target_stone"
parameter, in EVdfg the links between stones are established with the
EVdfg_link_port() function.

These are the basic DFG creation functions:
<table border> 
<tr> 
   <td><b> Function </b></td> 
   <td><b> Purpose </b></td> 
</tr> 

<tr> 
    <td> EVdfg_create_stone() </td> 
    <td> Create a stone with a specified action </td> 
</tr> 
<tr> 
    <td> EVdfg_add_action() </td> 
    <td> Add an action to an exiting stone  </td> 
</tr> 
<tr> 
    <td> EVdfg_create_source_stone() </td> 
    <td> Create a stone to source events </td> 
</tr> 
<tr> 
    <td> EVdfg_create_sink_stone() </td> 
    <td> Create a stone to be a sink for events  </td> 
</tr> 
<tr> 
    <td> EVdfg_add_sink_action() </td> 
    <td> Add a sink action to an existing stone  </td> 
</tr> 
<tr> 
    <td> EVdfg_link_port() </td> 
    <td> Connect the numeric output port on one stone to deliver events to another  </td> 
</tr> 
<tr> 
    <td> EVdfg_assign_node() </td> 
    <td> Assign an EVdfg_stone to be instantiated at a particular client node  </td> 
</tr> 
</table> 

\subsection examples Examples
\subsubsection two_node Two node - Two stone example
These functions, together with those described previously are enough to
create a couple of simple example programs: 
\ref dfg_master.c "dfg_master.c" 
\ref dfg_client.c "dfg_client.c" 

In order to run these, first run 'dfg_master' and you should see output like
this:
<Pre>
bash-3.2$ ./dfg_master
Contact list is "AAIBAClXsP6Cz2UZDW9pXpllAADViN+OAwAAAAUAZW5ldAAA"
</pre>
The text within the quotation marks is the contact string for the DFG.  Copy
it and use it as the first argument to dfg_client, like this:
<pre>
bash-3.2$ ./dfg_client "b" "AAIBAClXsP6Cz2UZDW9pXpllAADViN+OAwAAAAUAZW5ldAAA"
</pre>
On the master side, you should see the output "I got 318".

Some things to note about these examples:
- dfg_master creates only two stones, a source and a sink, assigning the
source to the client and the sink to the master (also participating in the DFG).
- Both dfg_master and dfg_client both use EVdfg_register_source() and
EVdfg_register_sink_handler(), so either could host either stone. (Try
swapping the values in EVdfg_assign_node().)  
- dfg_master can be the only node participating if you remove "b" from the
nodes[] array and assign the src stone to "a".  
- We pass the client name ("b") on the command line so that we can use it in
the next example as well.
- This particular example does not terminate.  We'll cover EVdfg's
termination facilities shortly.

\subsubsection three_node Three node - Three stone example

In order to change the above two node example to something that covers three
nodes, we only need modify the nodes array:
	     
  \snippet dfg_master2.c Changed nodes array

And change the DFG creation section so that it creates three stones for us
to assign:

  \snippet dfg_master2.c Changed DFG Creation

This example, \ref dfg_master2.c "dfg_master2.c" 
 is run like the first, but with two clients:
<pre>
bash-3.2$ ./dfg_master2
Contact list is "AAIBAClXsP7AqAF3DW9pXsplAADViN+OAwAAAAUAZW5ldAAA"
</pre>
<pre>
bash-3.2$ ./dfg_client "b" "AAIBAClXsP7AqAF3DW9pXsplAADViN+OAwAAAAUAZW5ldAAA" &
bash-3.2$ ./dfg_client "c" "AAIBAClXsP7AqAF3DW9pXsplAADViN+OAwAAAAUAZW5ldAAA"
</pre>

Some things to note about this example:
- dfg_master creates three stones, a source, an intermediate and a sink,
assigned to nodes "a", "b" and "c" respectively.
- Any node could host the source or host the sink.  Node "b" ends up doing
neither. 

\subsection termination EVdfg Termination

In the previous examples, the final call is CMrun_network(cm), which
essentially tells EVPath to handle incoming network messages forever.
However, while not necessarily suitable for all circumstances, EVdfg does
contain a facility for coordinating shutdown between participating EVdfg
processes, and even providing them with a common value to pass to exit().
The facility was designed expressly to support the EVdfg regression tests,
but it finds use in other circumstances.

The EVdfg shutdown facility generally requires a contribution from all
participating nodes before it authorizes shutdown, and if any node indicates
a <tt>Failure</tt> (non-zero) status the all nodes should indicate
<tt>Failure</tt>. However, what type of
contribution is appropriate from each node depends upon its circumstances.  
For example, consider the three node example above.  If it were a regression
test, it should be considered successful only if the event is submitted and
received at the destination with the expected value.  
For the node hosting the source, it is ready for shutdown only after it has
submitted its event, and if it reaches that point then it considers its
participation a success.  For the node hosting the sink, it is ready for
shutdown only after it has the event, and then it considers the test a
success or failure depending upon the value of received data.  The node
hosting neither the source nor sink is a bit trickier.  Essentially it
shouldn't shutdown until the others say they are ready, and it has no
specific contribution to the determination of success or failure of the
test.  

In order to support all of these circumstances, EVdfg has some informational
functions that let the application write shutdown code that doesn't
explicitly depend upon how the stones are mapped to nodes.  One of these
functions is the EVdfg_source_active() function that was introduced above.
Another is EVdfg_active_sink_count(), which returns the number of sinks that
have been mapped to the current node.  We'll use these, along with the EVdfg
shutdown functions, EVdfg_shutdown(), EVdfg_ready_for_shutdown() and
EVdfg_wait_for_shutdown(), in order to cleanly handle shutdown in our
example programs. 

In particular, in the place of the call to CMrun_network() we'll use the
following code segment in both master and client:
  \snippet dfg_client3.c Shutdown code
Additionally, we add the line:
<pre>
    EVdfg_shutdown((EVdfg)client_data, event->integer_field == 318);
</pre>
to the simpler_handler function.  With these changes, all processes end up
in EVdfg_wait_for_shutdown() instead of CMrun_network().  Additionally:
- node "a", which hosts only the source calls EVdfg_shutdown(dfg, 0)
<em>after</em> it has done EVsubmit().
- node "b", which hosts only the intermediate node calls
EVdfg_ready_for_shutdown() as soon as it starts running.
- node "c", which hosts the terminal stone, calls none of these calls prior
to EVdfg_wait_for_shutdown().  But it calls EVdfg_shutdown() in the handler,
passing in <tt>event->integer_field == 318</tt> as the success value.

That EVdfg_wait_for_shutdown() is in the return statement means that each
node will exit() with the same result code, which will be a success code if
the event is delivered properly.

These examples, \ref dfg_master3.c "dfg_master3.c"  and \ref dfg_client3.c "dfg_client3.c"  are 
run like the three node example above.

Another example, \ref dfg_master4.c "dfg_master4.c" is a "dynamic joining"
version of dfg_master3.  Run dfg_master4 with two instances of dfg_client3,
but it doesn't matter what the first argument to dfg_client3 is.  The first
one to join will be given the canonical name "b" and the second one will be
given "c".  The second will have the sink stone and show the expected
output.

\subsection Reconfiguration Reconfiguration
EVdfg allows reconfiguration, changing the layout and contents of the DFG,
after the initial realization; either upon node failure (as detected by a
write file in the DFG), the joining of a new node, or through voluntary
reconfiguration (via a CoD handler in the DFG calling
EVdfg_trigger_reconfiguration()).

The mechanism through which this reconfiguration is accomplish is currently
being rewritten, so documentation will follow.
*/

