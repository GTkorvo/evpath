/*! 
 \page evdfg The EVdfg interface

 \section evdfg-intro EVdfg interface

EVdfg is designed to be a relatively thin layer on top of EVPath that 
enables whole-system multi-process deployment of Data Flow Graphs implemented
with EVPath stones.  Like EVPath, EVdfg has abstractions to create stones,
to assign actions to them, to link stones to each other and to create
sources and sinks of data.  However, in EVdfg the stones created are a
virtual representation of the actual data flow graph that is to be realized
in EVPath, with EVdfg controlling the mapping (and potentially remapping) of
EVPath stones to the participating processes (nodes).

In particular, in EVdfg a single, differentiated 'Master' process is
responsible for defining the entire DFG.  Code in the master creates the virtual
stones, assigns actions to those stones, links them together to create the
topology, and assigns stones to nodes.  It also determines when sufficient
client processes have joined the DFG, either by specifying a static list, or
by making a decision in a handler as each new client process joins.  Once
all required nodes have joined and the virtual DFG has been created, it is
<i>realized</i> by the master (I.E. actual EVPath stones are created at the
appropriate places) and starts running.  The master may also register
handlers that can be called in the event of new nodes joining, an existing
node becoming unreachable, or a stone calling for reconfiguration.  In the
case of each of these, the master may rearrange the set of virtual stones,
moving some, adding others, changing links, etc. and then can realize the
changed DFG.  The master can also arbitrate an orderly shutdown of all
participating processes with an agreed-upon exit value.

Generally, but not necessarily, the master process is also a client and a
participant in the DFG.  The other participating processes are relatively
passive.  They identify their capabilities to the master, but do not
directly contribute stones to the DFG instead accepting the stones that are
assigned to them.

\subsection joining The Joining Process

The subroutine EVdfg_join_dfg() is used to join a client to a master and by
the master process to initiate participation in the DFG it controls.  The
goal of the joining process is for EVdfg to know when all participating
processes have joined and to have a unique name for each process (string
node names are used for stone assignment).  

\subsubsection static_joining Static Joining mode

In the simplest form of the
join, called `static joining' mode, the following things occur:
- Each joining node provides a unique name under which it participates in
the DFG.
- The master provides a fixed list of the names of nodes that must join.
- The joining process is complete when all named nodes have joined.

In this static mode, the pseudocode for the master looks like this:
\code{.c}
    EVdfg test_dfg;
    char *str_contact;
    char *nodes[] = {"a", "b", NULL};

    /* CM initialization and EVdfg capability registration occurs here */

    test_dfg = EVdfg_create(cm);
    str_contact = EVdfg_get_contact_list(test_dfg);
    EVdfg_register_node_list(test_dfg, &nodes[0]);

    /* EVdfg stone creation and assignment occurs here */

    EVdfg_realize(test_dfg);

    /* We're node "a" in the DFG */
    EVdfg_join_dfg(test_dfg, "a", str_contact);

    /* Somehow provide str_contact to the other participant(s) */

    /* Wait until everyone has joined */
    EVdfg_ready_wait(test_dfg);
\endcode

While the client is somewhat simpler:
\code{.c}
    EVdfg test_dfg;
    char *str_contact;

    /* CM initialization and EVdfg capability registration occurs here */

    test_dfg = EVdfg_create(cm);

    /* We're node "b" in the DFG */
    EVdfg_join_dfg(test_dfg, "b", str_contact);

    /* Wait until everyone has joined */
    EVdfg_ready_wait(test_dfg);
\endcode


\subsubsection dynamic_joining Dynamic Joining mode

There are situations in which the "static joining" scenario described above
is too rigid.  'Dynamic Joining' mode relaxes several requirements above.
First, rather than using a static node list (via
EVdfg_register_node_list()) and creating the entire virtual DFG before all
the nodes join, the master registers a EVdfgJoinHandlerFunc which is called
each time a client joins.  This join function may use its own criterion in
deciding when sufficient clients have joined.  When it decides that enough
have joined, then it should create the virtual DFG and call
EVdfg_realize().  In this situation, the requirement that each client
process specify a unique name to EVdfg_join_dfg() is also relaxed.  Instead,
each client can specify a generic name (like "client") and the join handler
can associate a unique canonical name with that client using
EVdfg_assign_canonical_name().  In this case, the canonical names assigned
must be unique and are the names used in EVdfg_assign_node().

In dynamic mode, the pseudocode for the client is unchanged (except that the
specified name need not be unique).  But the code structure for the master
is changes:
\code{.c}
    EVdfg test_dfg;
    char *str_contact;

    /* CM initialization and EVdfg capability registration occurs here */

    test_dfg = EVdfg_create(cm);
    str_contact = EVdfg_get_contact_list(test_dfg);
    EVdfg_node_join_handler (test_dfg, join_handler_func);

    /* We're node "a" in the DFG */
    EVdfg_join_dfg(test_dfg, "client", str_contact);

    /* Somehow provide str_contact to the other participant(s) */

    /* Wait until everyone has joined */
    EVdfg_ready_wait(test_dfg);
\endcode
The join handler function in dynamic mode will generally follow this form:
\code{.c}
void
join_handler_func(EVdfg dfg, char *identifier, void*cur_unused1, void*cur_unused2)
{
    char *canon_name;
    /* Generate a canonical name for this client in canon_name, then assign */
    EVdfg_assign_canonical_name(dfg, identifier, canon_name*/

    if ( /* not ready to start running */) return;

    /* EVdfg stone creation and assignment occurs here */

    EVdfg_realize(dfg);
    /* 
     * upon return, the DFG will be instantiated and all clients fall out
     * of EVdfg_ready_wait();
     */
}
\endcode
The join handler function is also used for dynamic reconfiguration of the
DFG, described later.

\subsection capability EVdfg Capability Registration

The phrase "EVdfg capability registration" occurs in the pseudocode comments
above.  Due to the dynamic code generation and FFS-based data representation
in EVPath, many stones can be placed on any process, without regard to
architecture, OS or other considerations.  However data sources and data
sinks necessarily require the cooperation of the receiving process.  In
particular, for an actual EVpath EVsource handle, the process must itself
call EVsubmit() on that handle.  For a sink (an EVPath terminal action,
where data is delivered to a native subroutine), EVdfg must know the jump
address for that subroutine and the exact format of data that it expects.

In order to preserve flexibility for the master to map the DFG to the nodes
as it desires, sources and sink handlers are presented as 'capabilities' in
EVdfg.  That is, sources are created by clients and made available for use,
but the master may or may not actually use them.  Similarly, the jump
addresses and data expectations of handler subroutines are associated with
"handler names" in the client.  Stones with sink actions associated with
those handler names may or may not be assigned individual clients.

\subsubsection source_capability EVdfg Source Capabilities

EVdfg clients register source capabilities by first creating an EVPath
source handle as in normal EVPath, but specifying -1 as the target stone
ID.  Then the EVdfg routine EVdfg_register_source() is used to associate a
name with the source handle.  Unlike EVPath, where EVsource handles are
associated with particular local stones, but are not considered stones
themselves, EVdfg sources are full virtual stones, assignable to different
clients like other virtual stones.  The master creates them with
EVdfg_create_source_stone(), specifying a source name.  This source name
must match a registered source on the client to which the source stone is
assigned.  Source names should be unique within each client, no client
EVsource handle can have more than one EVdfg_stone associated with it.

\subsubsection sink_capability EVdfg Sink Capabilities

EVdfg clients register sink (terminal handler) capabilities by using the
routine EVdfg_register_sink_handler().  Essentially, this establishes an
association between an particular handler subroutine, the FMStructDescList
describing the data it expects, and a handler name.  The master creates sink
stones with EVdfg_create_sink_stone(), or associates a new sink action with
an existing stone with EVdfg_add_sink_action().  In each case, the
handler_name specified in the call must match one that has appeared in a
EVdfg_register_sink_handler() call on the client to which that sink stone
is assigned.  Unlike sources, there is no restriction on how many different
sink stones may be associated with the same sink handler.

\subsubsection run_time Run-time Semantics

It is sometimes useful to clients to know, after a DFG has been realized, if
a particular local source has had an EVdfg source stone associated with it.
The routine EVdfg_source_active(EVsource src) returns a boolean value on
this condition (True if associated, False if not).  During DFG run-time,
clients usually test if a source is active so that they know if data is to
be submitted to it, as in the code below:
\code{.c}
    if (EVdfg_source_active(source_handle)) {
	simple_rec rec;
	generate_simple_record(&rec);
	/* submit would be quietly ignored if source is not active */
	EVsubmit(source_handle, &rec, NULL);
    }
\endcode
As the code comments indicate, a submit to an inactive source would be
quietly ignored by EVPath, but it's better form to test first.

For local sinks, that the actual handler gets called when data arrives is
the only real indication that a source handle has been utilized.  However, a
count of the total sink stones assigned to a particular node is available
via the routine EVdfg_active_sink_count(EVdfg dfg).  This is sometimes
useful for clients who need to know if they should be waiting for particular
data before signalling for shutdown, or if they are just waiting patiently
for the other nodes to complete operation.

\subsubsection capability_example Capability Example 
The code below is a sample for a client that is capable of being a source
for "simple" data, or for hosting terminal stones that handle "simple" data.
\code{.c}
    source_handle = EVcreate_submit_handle(cm, -1, simple_format_list);
    EVdfg_register_source("data_source", source_handle);
    EVdfg_register_sink_handler(cm, "simple_handler", simple_format_list,
				(EVSimpleHandlerFunc) simple_handler);
\endcode


\subsection  EVdfg Stone Creation and Assignment

In EVdfg, DFG stone creation occurs much like it does in raw EVPath with a
few major differences:
- The entire DFG is created and ports linked between EVdfg_stones without regard
to what nodes the participating stones might be assigned to.
- EVdfg_assign_node() is used to actually assign EVdfg_stones to specific nodes.
- Bridge stones are not directly created.  Instead, EVdfg inserts bridge
stones transparently when there is a connection between stones assigned to
different nodes.
- EVdfg uses 'source stones', first class enties which can be assigned to
specific nodes like any other EVdfg_stone.
- EVdfg_stones without any other explicit action associated with them act as
split stones.
- While many EVpath action assignment functions have a "target_stone"
parameter, in EVdfg the links between stones are established with the
EVdfg_link_port() function.


*/
