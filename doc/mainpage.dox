/*!\mainpage The EVpath Library

 \section intro Introduction

EVpath is designed to be an event transport middleware layer.
Specifically, it is designed to allow for the easy implementation of
overlay networks, with active data processing, routing and management at
all points in the overlay.

EVpath specifically does not encompass global overlay creation,
management or destruction functions.  Rather it focusses on providing
efficient environment for routine transport, while providing
interfaces necessary for external management layers.

The package is built around the concept of <em>"stones"</em> (like
stepping stones) which are linked to build end-to-end
<em>"paths"</em>.  While the <em>"path"</em> is not an explicitly
supported construct in EVpath, the goal is to provide all the local,
stone-level, support necessary to accomplish their setup, monitoring,
management, modification and tear-down.

Stones in EVpath are lightweight entities that roughly correspond to
processing points in dataflow diagrams.  Stones of different types
perform data filtering, data transformation, mux and demux of data as well
as transmission of data between processes over network links.

 \section types Stone Types

Connected collections of stones (or paths) specify a particular flow
path of data, typically a directed acyclic graph, across a complete
distributed system.  Before detailing the various types of stones,
we'll examine some sample applications that drove the development of
EVPath.  For example, one might use stones to build an overlay network
to distribute data from the data source to the sinks, as is shown below:
\image html overlay.jpg 
\image latex overlay.pdf

We can also imagine that each of those sinks might actually want a
slightly customized version of the event stream (with sink i
customizing it's stream with function i) and that an efficient
implementation of event delivery would place those filter functions as
close to the source as possible to avoid transmitting data that is
only to be discarded later.
\image html func1.jpg 
\image latex func1.pdf

A yet more efficient implementation, armed with knowledge of the nature of
functions 1 through 4 might use that knowledge to introduce combined
filter functions, for example using filter FC to eliminate data that
would be rejected by both filters F3 anf F4 before it is sent.


 \section comm Communication

 \section control Control Flow
*/
